From 0084fd113af3cf288fc66db6eb1a32adcc3498d9 Mon Sep 17 00:00:00 2001
From: blozh <1165884639@qq.com>
Date: Fri, 9 Nov 2018 22:33:53 +0800
Subject: [PATCH] =?UTF-8?q?=E6=89=93=E7=AE=97=E9=87=8D=E6=96=B0=E7=9C=8B?=
 =?UTF-8?q?=E4=B8=80=E9=81=8D=E7=90=85=E7=90=8A=E6=A6=9C?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 Compiles/Analysis.java | 36 ++++++++++++++++++++++++++++--------
 1 file changed, 28 insertions(+), 8 deletions(-)

diff --git a/Compiles/Analysis.java b/Compiles/Analysis.java
index 2113494..a193873 100644
--- a/Compiles/Analysis.java
+++ b/Compiles/Analysis.java
@@ -526,7 +526,7 @@ final class Analysis {
     static DefaultTableModel DGmodel2;
     private static void DGoutput(String str,int x,int y){
         DGnum++;
-        DGmodel.addRow(new String[]{DGnum + "", "", str, ""});
+        DGmodel.addRow(new String[]{DGnum + "", str, "", ""});
         String t=DGmodel2.getValueAt(x,y).toString();
         DGmodel2.setValueAt(t+' ',x,y);
         try {
@@ -642,7 +642,10 @@ final class Analysis {
             return p;
         }
         if(a.charAt(p)=='+'||a.charAt(p)=='-'){
-            DGoutput("Z11->+TZ11 | Z11->-TZ11",3,1);
+            if(a.charAt(p)=='+')
+                DGoutput("Z11->+TZ11",3,1);
+            else
+                DGoutput("Z11->-TZ11",3,2);
             p++;
             p=T(a,p);
             if(p<0)
@@ -660,13 +663,15 @@ final class Analysis {
     }
 
     private static int Z12(String a,int p){
-
         if(a.length()==p) {
             DGoutput("Z11->ε",4,3);
             return p;
         }
         if(a.charAt(p)=='+'||a.charAt(p)=='-'){
-            DGoutput("Z12->+TZ12 | Z12->-TZ12",4,1);
+            if(a.charAt(p)=='+')
+                DGoutput("Z12->+TZ12",4,1);
+            else
+                DGoutput("Z12->-TZ12",4,2);
             p++;
             p=T(a,p);
             if(p<0)
@@ -690,7 +695,10 @@ final class Analysis {
             return p;
         }
         if(a.charAt(p)=='+'||a.charAt(p)=='-'){
-            DGoutput("Z13->+TZ13 | Z12->-TZ13",5,1);
+            if(a.charAt(p)=='+')
+                DGoutput("Z13->+TZ13",5,1);
+            else
+                DGoutput("Z13->-TZ13",5,2);
             p++;
             p=T(a,p);
             if(p<0)
@@ -710,11 +718,15 @@ final class Analysis {
     private static int Z21(String a,int p){
 
         if(a.length()==p){
+            DGoutput("Z21->Z11",6,1);
             DGoutput("Z11->ε",3,3);
             return p;
         }
         if(a.charAt(p)=='*'||a.charAt(p)=='/'){
-            DGoutput("Z21->*FZ12 | Z21->/FZ21",6,2);
+            if(a.charAt(p)=='*')
+                DGoutput("Z21->*FZ12",6,2);
+            else
+                DGoutput("Z21->/FZ21",6,3);
             p++;
             p=F(a,p);
             if(p<0)
@@ -737,11 +749,15 @@ final class Analysis {
 
     private static int Z22(String a,int p){
         if(a.length()==p){
+            DGoutput("Z22->Z12",7,1);
             DGoutput("Z12->ε",4,3);
             return p;
         }
         if(a.charAt(p)=='*'||a.charAt(p)=='/'){
-            DGoutput("Z22->*FZ22 | Z21->/FZ22",7,2);
+            if(a.charAt(p)=='*')
+                DGoutput("Z22->*FZ22",7,2);
+            else
+                DGoutput("Z21->/FZ22",7,3);
             p++;
             p=F(a,p);
             if(p<0)
@@ -764,11 +780,15 @@ final class Analysis {
 
     private static int Z23(String a,int p){
         if(a.length()==p){
+            DGoutput("Z23->Z13",8,1);
             DGoutput("Z13->ε",5,3);
             return p;
         }
         if(a.charAt(p)=='*'||a.charAt(p)=='/'){
-            DGoutput("Z23->*FZ23 | Z23->/FZ23",8,2);
+            if(a.charAt(p)=='*')
+                DGoutput("Z23->*FZ23",8,2);
+            else
+                DGoutput("Z23->/FZ23",8,3);
             p++;
             p=F(a,p);
             if(p<0)
-- 
2.21.0.windows.1

From d7bfb8bc405f9aadba6c5658bbf094e996b51479 Mon Sep 17 00:00:00 2001
From: blozh <1165884639@qq.com>
Date: Tue, 30 Oct 2018 20:15:57 +0800
Subject: [PATCH] =?UTF-8?q?=E8=AF=AD=E6=B3=95=E5=88=86=E6=9E=90?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 ATest/ABC.java              |  30 ---
 ATest/ATest.java            |   4 +-
 Compiles/Analysis.java      | 504 +++++++++++++++++++++++-------------
 Compiles/LexicalWindow.java | 409 +++++++++++++++--------------
 Compiles/ParseWindow.java   |  53 ++--
 5 files changed, 564 insertions(+), 436 deletions(-)
 delete mode 100644 ATest/ABC.java

diff --git a/ATest/ABC.java b/ATest/ABC.java
deleted file mode 100644
index 9dae39f..0000000
--- a/ATest/ABC.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package ATest;
-
-class NoWater extends Exception {}
-class NoDrinkableWater extends NoWater {}
-
-public class ABC {
-    static int count = 0;
-    public static void main(String[] args) throws NoWater {
-        while ( true ) {
-            try {
-                count++;
-                if ( count == 1 ) {
-                    System.out.println("OK");
-                } else if ( count == 2 ) {
-                    System.out.println("Exception raised: NoDrinkableWater");
-                    throw new NoDrinkableWater();
-                } else if ( count == 3 ) {
-                    System.out.println("Exception raised: NoWater");
-                    throw new NoWater();
-                }
-            } catch (NoDrinkableWater e) {
-                System.out.println(e);
-            } finally {
-                System.out.println("finally");
-                if ( count == 3 )
-                    break;
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/ATest/ATest.java b/ATest/ATest.java
index 36ccb94..60822a6 100644
--- a/ATest/ATest.java
+++ b/ATest/ATest.java
@@ -7,8 +7,8 @@ import java.util.Scanner;
 public class ATest {
 
     public static void main(String[] args) {
-        Scanner sc=new Scanner(System.in);
-        int a=Integer.parseInt(sc.next());
+
+        int a=Integer.parseInt("R15");
         System.out.println(a);
 
         }
diff --git a/Compiles/Analysis.java b/Compiles/Analysis.java
index 84a4614..ef6ab5d 100644
--- a/Compiles/Analysis.java
+++ b/Compiles/Analysis.java
@@ -3,6 +3,7 @@ package Compiles;
 import java.awt.Color;
 import java.awt.Component;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 import javax.swing.JFrame;
@@ -21,17 +22,17 @@ final class Analysis {
     private static ArrayList<String> errors;
     private static ArrayList<Integer> errorsRows;
 
-    private static boolean isAlpha(char c){
-        return ((c<='z')&&(c>='a')) || ((c<='Z')&&(c>='A')) || (c=='_');
+    private static boolean isAlpha(char c) {
+        return ((c <= 'z') && (c >= 'a')) || ((c <= 'Z') && (c >= 'A')) || (c == '_');
     }
 
-    private static boolean isNumber(char c){
-        return (c>='0')&&(c<='9');
+    private static boolean isNumber(char c) {
+        return (c >= '0') && (c <= '9');
     }
 
-    private static boolean isKey(String t){
-        String[] key={"begin","end","if","then","else","if","then","public","private","protected"};
-        for(int i=0;i<key.length;i++){
+    private static boolean isKey(String t) {
+        String[] key = {"begin", "end", "if", "then", "else", "if", "then", "public", "private", "protected"};
+        for (int i = 0; i < key.length; i++) {
             if (t.equals(key[i])) {
                 return true;
             }
@@ -40,95 +41,89 @@ final class Analysis {
     }
 
     //数字合法结束符号
-    private static boolean isEnd(char t){
-        return t==' '||t=='\t'||t=='\n'||t=='\0'||
-                t==';'||t==','||t=='+'||t=='-'||t=='*'||
-                t=='/'||t==')'||t=='}'||t==']'||t=='|'||t=='&';
+    private static boolean isEnd(char t) {
+        return t == ' ' || t == '\t' || t == '\n' || t == '\0' ||
+                t == ';' || t == ',' || t == '+' || t == '-' || t == '*' ||
+                t == '/' || t == ')' || t == '}' || t == ']' || t == '|' || t == '&';
     }
 
-    public static void LexicalAnalysis(String input){
-        values=new ArrayList<>();
-        types=new ArrayList<>();
-        errors=new ArrayList<>();
-        errorvalues=new ArrayList<>();
-        errorsRows=new ArrayList<>();
+    public static void LexicalAnalysis(String input) {
+        values = new ArrayList<>();
+        types = new ArrayList<>();
+        errors = new ArrayList<>();
+        errorvalues = new ArrayList<>();
+        errorsRows = new ArrayList<>();
 
-        int rowNum=1;
+        int rowNum = 1;
 
         char c;
-        input+='\0';//作为字符串结束标志，保证字符串读取到最后一个时，还可以提前读取最后一个字符的下一个字符
+        input += '\0';//作为字符串结束标志，保证字符串读取到最后一个时，还可以提前读取最后一个字符的下一个字符
         //因此for循环中 input.length()-1
-        for(int i=0;i<input.length()-1;i++){
-            c=input.charAt(i);
-            if(c=='\n'){//在界面代码中，已经把所有换行符都转变为\n了，不需要考虑\r
+        for (int i = 0; i < input.length() - 1; i++) {
+            c = input.charAt(i);
+            if (c == '\n') {//在界面代码中，已经把所有换行符都转变为\n了，不需要考虑\r
                 rowNum++;
             }
             //如果读取到空格或者\t 继续读取下一个字符串 为了删除多行注释这里不能放\n
-            else if(c!=' '&&c!='\t'){
-                String s="";
+            else if (c != ' ' && c != '\t') {
+                String s = "";
                 //判断第一个输入的字符
-                if(isAlpha(c)){
-                    s+=c;
-                    char temp=input.charAt(++i);//查看下一个字符
+                if (isAlpha(c)) {
+                    s += c;
+                    char temp = input.charAt(++i);//查看下一个字符
                     //只有下一个字符是字母或数字时循环才运行
-                    while(isAlpha(temp)||isNumber(temp)){
-                        s+=temp;
-                        temp=input.charAt(++i);
+                    while (isAlpha(temp) || isNumber(temp)) {
+                        s += temp;
+                        temp = input.charAt(++i);
                     }
-                    if(isKey(s)){
+                    if (isKey(s)) {
                         types.add(s.toUpperCase());
                         values.add(" ");
-                    }
-                    else{
+                    } else {
                         types.add("ID");
                         values.add(s);
                     }
-                }
-                else if(isNumber(c)){
-                    s+=c;
-                    char temp=input.charAt(++i);
-                    while(isNumber(temp)){
-                        s+=temp;
-                        temp=input.charAt(++i);
+                } else if (isNumber(c)) {
+                    s += c;
+                    char temp = input.charAt(++i);
+                    while (isNumber(temp)) {
+                        s += temp;
+                        temp = input.charAt(++i);
                     }
-                    if(isEnd(temp)){
+                    if (isEnd(temp)) {
                         types.add("UCON_整数");
                         values.add(s);
-                    }
-                    else if(temp=='.'&&isNumber(input.charAt(i+1))){
-                        s+='.';
-                        temp=input.charAt(++i);
-                        while(isNumber(temp)){
-                            s+=temp;
-                            temp=input.charAt(++i);
+                    } else if (temp == '.' && isNumber(input.charAt(i + 1))) {
+                        s += '.';
+                        temp = input.charAt(++i);
+                        while (isNumber(temp)) {
+                            s += temp;
+                            temp = input.charAt(++i);
                         }
-                        if(isEnd(temp)){
+                        if (isEnd(temp)) {
                             types.add("UCON_小数");
                             values.add(s);
-                        }
-                        else{
-                            while(!isEnd(temp)){
-                                s+=temp;
-                                temp=input.charAt(++i);
+                        } else {
+                            while (!isEnd(temp)) {
+                                s += temp;
+                                temp = input.charAt(++i);
                             }
                             errors.add("小数错误");
                             errorvalues.add(s);
                             errorsRows.add(rowNum);
                         }
-                    }
-                    else{
-                        while(!isEnd(temp)){
-                            s+=temp;
-                            temp=input.charAt(++i);
+                    } else {
+                        while (!isEnd(temp)) {
+                            s += temp;
+                            temp = input.charAt(++i);
                         }//eg 12.3edfe,此循环用于略过edfe这四个字母
                         errors.add("数字错误");
                         errorvalues.add(s);
                         errorsRows.add(rowNum);
                     }
-                }
-                else{
-                    s+=c;
-                    switch (c){
+                } else {
+                    s += c;
+                    switch (c) {
                         case '[':
                         case ']':
                         case '(':
@@ -161,81 +156,92 @@ final class Analysis {
                             values.add(s);
                             i++;
                             break;
-                        case'/':
-                            if(input.charAt(i+1)=='/'){
+                        case '/':
+                            if (input.charAt(i + 1) == '/') {
                                 i++;
-                                char temp=input.charAt(++i);
-                                while(temp!='\n'&&temp!='\0'){
-                                    temp=input.charAt(++i);//略过注释
+                                char temp = input.charAt(++i);
+                                while (temp != '\n' && temp != '\0') {
+                                    temp = input.charAt(++i);//略过注释
                                 }
                                 break;
-                            }
-                            else if(input.charAt(i+1)=='*'){
+                            } else if (input.charAt(i + 1) == '*') {
                                 i++;
-                                char temp=input.charAt(++i);
-                                while(temp!='*'||input.charAt(i+1)!='/'){
-                                    temp=input.charAt(++i);//略过注释
+                                char temp = input.charAt(++i);
+                                while (temp != '*' || input.charAt(i + 1) != '/') {
+                                    temp = input.charAt(++i);//略过注释
                                 }
-                                i+=2;
+                                i += 2;
                                 break;
-                            }
-                            else{
+                            } else {
                                 types.add("DI");
                                 values.add(s);
                                 i++;
                                 break;
                             }
-                        case':':
-                            if(input.charAt(i+1)=='='){
-                                s+='=';
-                                i+=2;
+                        case ':':
+                            if (input.charAt(i + 1) == '=') {
+                                s += '=';
+                                i += 2;
                                 types.add("IS");
                                 values.add(s);
-                            }
-                            else {
+                            } else {
                                 errors.add("IS错误");
                                 errorvalues.add(s);
                                 errorsRows.add(rowNum);
                                 i++;//略过错误号
                             }
                             break;
-                        case'|':
-                        case'&':
-                            if(input.charAt(i+1)==input.charAt(i)){
-                                s+=input.charAt(i);
-                                i+=2;
+                        case '|':
+                        case '&':
+                            if (input.charAt(i + 1) == input.charAt(i)) {
+                                s += input.charAt(i);
+                                i += 2;
                                 types.add("短路逻辑运算符");
                                 values.add(s);
-                            }
-                            else {
+                            } else {
                                 types.add("非短路逻辑运算符");
                                 values.add(s);
                                 i++;//略过错误号
                             }
                             break;
                         case '>':
-                        case'<':
-                            if(input.charAt(i+1)=='='){
-                            s+='=';
-                            i+=2;
-                            }
-                            else if(c=='<'&&input.charAt(i+1)=='>'){
-                                s+='>';
-                                i+=2;
-                            }
-                            else {
+                        case '<':
+                            if (input.charAt(i + 1) == '=') {
+                                s += '=';
+                                i += 2;
+                            } else if (c == '<' && input.charAt(i + 1) == '>') {
+                                s += '>';
+                                i += 2;
+                            } else {
                                 i++;//略过
                             }
-                            switch (s){
-                                case">":types.add("GT");values.add(s);break;
-                                case">=":types.add("GE");values.add(s);break;
-                                case"<":types.add("LT");values.add(s);break;
-                                case"<=":types.add("LE");values.add(s);break;
-                                case"<>":types.add("NE");values.add(s);;break;
+                            switch (s) {
+                                case ">":
+                                    types.add("GT");
+                                    values.add(s);
+                                    break;
+                                case ">=":
+                                    types.add("GE");
+                                    values.add(s);
+                                    break;
+                                case "<":
+                                    types.add("LT");
+                                    values.add(s);
+                                    break;
+                                case "<=":
+                                    types.add("LE");
+                                    values.add(s);
+                                    break;
+                                case "<>":
+                                    types.add("NE");
+                                    values.add(s);
+                                    ;
+                                    break;
                             }
                             break;
                         case '=':
-                            types.add("EQ");values.add(s);
+                            types.add("EQ");
+                            values.add(s);
                             i++;
                             break;
                         default:
@@ -270,137 +276,261 @@ final class Analysis {
         return errorsRows;
     }
 
-    /*语法分析*/
+    /*语法分析-算符优先*/
     //规约式转换
-    static char reduce(String x){
-        if(x.length()==1)
+    static char reduce(String x) {
+        if (x.length() == 1)
             return 'F';
-        else if(x.charAt(0)=='(')
+        else if (x.charAt(0) == '(')
             return 'F';
-        char[] from={'*','/','+','-'};
-        char[] to={'T','T','E','E'};
+        char[] from = {'*', '/', '+', '-'};
+        char[] to = {'T', 'T', 'E', 'E'};
         for (int i = 0; i < from.length; i++) {
-            if(from[i]==x.charAt(1))
+            if (from[i] == x.charAt(1))
                 return to[i];
         }
         return ' ';
     }
 
     //用于输出到表格中的规则式转换
-    static String reduceGongshi(String x){
-        if(x.length()==1)
+    static String reduceGongshi(String x) {
+        if (x.length() == 1)
             return "F->i";
-        else if(x.charAt(0)=='(')
+        else if (x.charAt(0) == '(')
             return "F->(E)";
-        char[] from={'*','/','+','-'};
-        String[] to={"T->T*F","T->T/F","E->E+T","E->E-T"};
+        char[] from = {'*', '/', '+', '-'};
+        String[] to = {"T->T*F", "T->T/F", "E->E+T", "E->E-T"};
         for (int i = 0; i < from.length; i++) {
-            if(from[i]==x.charAt(1))
+            if (from[i] == x.charAt(1))
                 return to[i];
         }
         return " ";
     }
 
     //判断是否为终结符
-    static boolean isVt(char x){
-        char[] vt={'i','(',')','+','-','*','/','#'};
+    static boolean isVt(char x) {
+        char[] vt = {'i', '(', ')', '+', '-', '*', '/', '#'};
         int i;
         for (i = 0; i < vt.length; i++) {
-            if(vt[i]==x)
+            if (vt[i] == x)
                 break;
         }
-        if(i==vt.length)
+        if (i == vt.length)
             return false;
         else
             return true;
     }
 
     //优先级判断，根据横纵坐标取出大小于符号,1为前者大于后者，0为等于，-1为小于
-    static int prioriyJudge(DefaultTableModel model2,char x,char y){
-        int xx=0,yy=0;
+    static int prioriyJudge(DefaultTableModel model2, char x, char y) throws Exception {
+        int xx = 0, yy = 0;
         for (int i = 0; i < model2.getRowCount(); i++) {
-            if(x==model2.getValueAt(i,0).toString().charAt(0))
-                xx=i;
-            if(y==model2.getValueAt(i,0).toString().charAt(0))
-                yy=i;
+            if (x == model2.getValueAt(i, 0).toString().charAt(0))
+                xx = i;
+            if (y == model2.getValueAt(i, 0).toString().charAt(0))
+                yy = i;
         }
-        int result=0;
-        switch (model2.getValueAt(xx,yy+1).toString()){
-            case ">":model2.setValueAt(">    █",xx,yy+1);result=1;break;
-            case "=":model2.setValueAt("=    █",xx,yy+1);result=0;break;
-            case "<":model2.setValueAt("<    █",xx,yy+1);result=-1;break;
+        int result = 2;
+        switch (model2.getValueAt(xx, yy + 1).toString()) {
+            case ">":
+                model2.setValueAt(">    █", xx, yy + 1);
+                result = 1;
+                break;
+            case "=":
+                model2.setValueAt("=    █", xx, yy + 1);
+                result = 0;
+                break;
+            case "<":
+                model2.setValueAt("<    █", xx, yy + 1);
+                result = -1;
+                break;
         }
         try {
             Thread.sleep(1000);
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
-        switch (result){
-            case 1:model2.setValueAt(">",xx,yy+1);break;
-            case 0:model2.setValueAt("=",xx,yy+1);break;
-            case -1:model2.setValueAt("<",xx,yy+1);break;
+        switch (result) {
+            case 1:
+                model2.setValueAt(">", xx, yy + 1);
+                break;
+            case 0:
+                model2.setValueAt("=", xx, yy + 1);
+                break;
+            case -1:
+                model2.setValueAt("<", xx, yy + 1);
+                break;
+            case 2:
+                throw new Exception("分析错误！");
         }
         return result;
     }
 
+    //主控程序
+    public static void ParseAnalysis(DefaultTableModel model, DefaultTableModel model2) {
+        model.setRowCount(0);//清空表格
+        int num = 0;//用于记录步骤
+        String a = "", stack = "#", Gongshi = "";
+        char r;
+        //将队列转换为字符串
+        for (int i = 0; i < types.size(); i++) {
+            if (types.get(i) == "UCON_小数" || types.get(i) == "UCON_整数")
+                a += "i";
+            else
+                a += values.get(i);
+        }
+        a += "#";
+        int i = 0, k = 0;//i为字符串指针，k为stack指针
+        try {
+            do {
+                int j;
+                r = a.charAt(i++);
+                if (isVt(stack.charAt(k)))
+                    j = k;
+                else
+                    j = k - 1;
+                while (prioriyJudge(model2, stack.charAt(j), r) > 0) {
+                    char q;
+                    do {
+                        q = stack.charAt(j);
+                        if (isVt(stack.charAt(j - 1)))
+                            j--;
+                        else
+                            j -= 2;
+                    } while (prioriyJudge(model2, stack.charAt(j), q) >= 0);
+                    char newVn = reduce(stack.substring(j + 1, k + 1));
+                    Gongshi = reduceGongshi(stack.substring(j + 1, k + 1));
+                    k = j + 1;
+                    stack = stack.substring(0, k);
+                    stack += newVn;
+                    num++;
+                    model.addRow(new String[]{num + "", stack, a.substring(i, a.length()), ""});
+                    model.setValueAt(Gongshi, model.getRowCount() - 2, 3);
+                }
+                if (prioriyJudge(model2, stack.charAt(j), r) <= 0) {
+                    stack += r;
+                    k++;
+                    num++;
+                    model.addRow(new String[]{num + "", stack, a.substring(i, a.length()), ""});
+                }
+            } while (r != '#');
+            model.addRow(new String[]{"RIGHT!", "RIGHT!", "RIGHT!", "RIGHT!"});
+        } catch (Exception e) {
+            model.addRow(new String[]{"ERROR!", "ERROR!", "ERROR!", "ERROR!"});
+        }
+    }
 
+    /*语法分析-SLR(1)*/
+
+    //将符号转换为对应的坐标
+    static int symbolLocation(char x) {
+        int xx = 0;
+        String[] strs = new String[]{"", "(", ")", "+", "-", "*", "/", "i", "#", "E", "T", "F"};
+        for (int i = 0; i < strs.length; i++) {
+            if ((x + "") .equals(strs[i]) )
+                xx = i;
+        }
+        return xx;
+    }
+
+    //表格内容是否为Sn
+    static boolean isSn(String x) {
+        return x.charAt(0) == 'S';
+    }
+
+    //表格内容是否为Rn
+    static boolean isRn(String x) {
+        return x.charAt(0) == 'R';
+    }
+
+    static String lefter(int n) {
+        String[] str = {"E'", "E", "E", "E", "T", "T", "T", "F", "F"};
+        return str[n];
+    }
+
+    static String righter(int n) {
+        String[] str = {"E", "E+T", "E-T", "T", "T*F", "T/F", "F", "(E)", "i"};
+        return str[n];
+    }
 
-        public static void ParseAnalysis(DefaultTableModel model, DefaultTableModel model2, JTable t2){
+    static String arrays2str(int[] a,int k){
+        String t="";
+        for(int i=0;i<=k;i++){
+            t+=a[i];
+            if(i!=k)
+                t+=',';
+        }
+        return t;
+    }
 
+    //主控程序
+    public static void ParseAnalysis_SLR(DefaultTableModel model, DefaultTableModel model2) {
         model.setRowCount(0);//清空表格
-        int num=0;//用于记录步骤
-        String a="",stack="#",Gongshi="";
-        char r;
+        int num = 0;//用于记录步骤
+        String a = "", stack2 = "#",temp;//temp用于存放表格中的内容
         //将队列转换为字符串
-        for(int i=0;i<types.size();i++){
-            if(types.get(i)=="UCON_小数"||types.get(i)=="UCON_整数")
-                a+="i";
+        for (int i = 0; i < types.size(); i++) {
+            if (types.get(i) == "UCON_小数" || types.get(i) == "UCON_整数")
+                a += "i";
             else
-                a+=values.get(i);
+                a += values.get(i);
+        }
+        a += "#";
+        int[] stack = new int[10];
+        stack[0] = 0;
+        int i = 0, k = 0;//i为字符串指针，k为stack指针
+        try {
+            do {
+                temp=model2.getValueAt(stack[k], symbolLocation(a.charAt(i))).toString();
+                String t=temp;//t是temp的备份
+                int t1=stack[k],t2=symbolLocation(a.charAt(i));
+                model2.setValueAt(temp+"  █",stack[k], symbolLocation(a.charAt(i)));
+                if (temp.equals("")) {
+                    //error
+                    throw new Exception("分析错误！");
+                }
+                //如果是Sn
+                else if (isSn(temp)) {
+                    temp=temp.substring(1,temp.length());
+                    stack[++k] = Integer.parseInt(temp);
+                    stack2 += a.charAt(i);
+                    num++;
+                    model.addRow(new String[]{num + "", stack2, a.substring(i, a.length()), ""});
+                    model.addRow(new String[]{"", arrays2str(stack,k), "", ""});
+                    i++;
+                }
+                //如果是Rn
+                else if (isRn(temp)) {
+                    //act(i) ，返回于第i个产生式的语义动作，分别返回左部文法和右部文法
+                    temp=temp.substring(1,temp.length());
+                    int n = Integer.parseInt(temp);
+                    String left = lefter(n);
+                    String right = righter(n);
+                    //pop(第i个产生式右部文法符号的个数），也把字符串stack中的产生式右部文法弹出
+                    k -= right.length();
+                    stack2 = stack2.substring(0, k + 1);
+                    //push(Goto[新的栈顶状态][第i个产生式左部文法])，把产生式的左部文法push进字符串stack
+                    temp=model2.getValueAt(stack[k], symbolLocation(left.charAt(0))).toString();
+                    stack[++k] = Integer.parseInt(temp);
+                    stack2 += left;
+                    num++;
+                    model.addRow(new String[]{num + "", stack2, a.substring(i, a.length()), ""});
+                    model.addRow(new String[]{"", arrays2str(stack,k), "", ""});
+                    model.setValueAt(left+"->"+right, model.getRowCount() - 4, 3);
+                }
+                Thread.sleep(1000);
+                model2.setValueAt(t,t1, t2);
+            }while(!temp.equals("Acc"));
+            //后续工作
+            model.addRow(new String[]{"RIGHT!", "RIGHT!", "RIGHT!", "RIGHT!"});
+        } catch (Exception e) {
+            //如果分析错误，那么。。
+            model.addRow(new String[]{"ERROR!", "ERROR!", "ERROR!", "ERROR!"});
         }
-        a+="#";
-        //System.out.println(a);
-        int i=0,k=0;//i为字符串指针，k为stack指针
-        do{
-            int j;
-            r=a.charAt(i++);
-            if(isVt(stack.charAt(k)))
-                j=k;
-            else
-                j=k-1;
-            while(prioriyJudge(model2,stack.charAt(j),r)>0){
-                char q;
-                do{
-                    q=stack.charAt(j);
-                    if(isVt(stack.charAt(j-1)))
-                        j--;
-                    else
-                        j-=2;
-                }while(prioriyJudge(model2,stack.charAt(j),q)>=0);
-                char newVn=reduce(stack.substring(j+1,k+1));
-                Gongshi=reduceGongshi(stack.substring(j+1,k+1));
-                k=j+1;
-                stack=stack.substring(0,k);
-                stack+=newVn;
-                num++;
-                model.addRow(new String[]{num+"",stack,a.substring(i,a.length()),""});
-                model.setValueAt(Gongshi,model.getRowCount()-2,3);
-            }
-            if(prioriyJudge(model2,stack.charAt(j),r)<=0){
-                stack+=r;
-                k++;
-                num++;
-                model.addRow(new String[]{num+"",stack,a.substring(i,a.length()),""});
-            }
-            else {
-                //写入error到表格
-                num++;
-                model.addRow(new String[]{"ERROR", "", "", ""});
-            }
-        }while(r!='#');
     }
+
     /*语义分析*/
-    public static void SenmanticAnalysis(String input){
+    public static void SenmanticAnalysis(String input) {
     }
 }
 
diff --git a/Compiles/LexicalWindow.java b/Compiles/LexicalWindow.java
index 97ebbd0..882981c 100644
--- a/Compiles/LexicalWindow.java
+++ b/Compiles/LexicalWindow.java
@@ -37,117 +37,116 @@ import javax.swing.JTable;
 import javax.swing.JTextArea;
 import javax.swing.table.DefaultTableModel;
 
-class LexicalWindow extends ModWindow{
-    private JButton[] buttons=new JButton[4];
-    private JTextArea[] textAreas =new JTextArea[2];
-    private JScrollPane[] scrollPanes=new JScrollPane[3];
-    private DefaultTableModel model=new DefaultTableModel();
-    private JTable table=new JTable(model);
+class LexicalWindow extends ModWindow {
+    private JButton[] buttons = new JButton[4];
+    private JTextArea[] textAreas = new JTextArea[2];
+    private JScrollPane[] scrollPanes = new JScrollPane[3];
+    private DefaultTableModel model = new DefaultTableModel();
+    private JTable table = new JTable(model);
 
-    LexicalWindow(){
-        model.setColumnIdentifiers(new String[]{"类别","单词"});
-        buttons[0]=new JButton("打开");
-        buttons[1]=new JButton("分析");
-        buttons[2]=new JButton("保存");
-        buttons[3]=new JButton("状态转换图");
-        textAreas[0]=new JTextArea();
-        textAreas[1]=new JTextArea();
+    LexicalWindow() {
+        model.setColumnIdentifiers(new String[]{"类别", "单词"});
+        buttons[0] = new JButton("打开");
+        buttons[1] = new JButton("分析");
+        buttons[2] = new JButton("保存");
+        buttons[3] = new JButton("状态转换图");
+        textAreas[0] = new JTextArea();
+        textAreas[1] = new JTextArea();
         textAreas[1].setEditable(false);
-        scrollPanes[0]=new JScrollPane(textAreas[0]);
-        scrollPanes[1]=new JScrollPane(textAreas[1]);
-        scrollPanes[2]=new JScrollPane(table);
+        scrollPanes[0] = new JScrollPane(textAreas[0]);
+        scrollPanes[1] = new JScrollPane(textAreas[1]);
+        scrollPanes[2] = new JScrollPane(table);
         panel.setLayout(gb);
-        gbc.weightx=1;//不为0时，网格横向扩大
-        gbc.fill= GridBagConstraints.HORIZONTAL;//组件允许横向扩大
-        for (int i=0;i<4;i++){
-            addJComponent(buttons[i],i,0,1,1);
+        gbc.weightx = 1;//不为0时，网格横向扩大
+        gbc.fill = GridBagConstraints.HORIZONTAL;//组件允许横向扩大
+        for (int i = 0; i < 4; i++) {
+            addJComponent(buttons[i], i, 0, 1, 1);
             buttons[i].addActionListener(this);//添加监听
             buttons[i].setBackground(Color.WHITE);
         }
-        gbc.fill=GridBagConstraints.BOTH;
-        for (int i=0;i<2;i++){
+        gbc.fill = GridBagConstraints.BOTH;
+        for (int i = 0; i < 2; i++) {
             textAreas[i].setFont(font);
-            gbc.weighty=6-i*5;//纵向扩大程度
-            addJComponent(scrollPanes[i],0,i+1,3,1);
+            gbc.weighty = 6 - i * 5;//纵向扩大程度
+            addJComponent(scrollPanes[i], 0, i + 1, 3, 1);
         }
-        addJComponent(scrollPanes[2],3,1,1,2);
-        textAreas[1].setBackground(new Color(230,230,230));
+        addJComponent(scrollPanes[2], 3, 1, 1, 2);
+        textAreas[1].setBackground(new Color(230, 230, 230));
     }
 
 
-
     @Override
     public void actionPerformed(ActionEvent actionEvent) {
-        if(actionEvent.getActionCommand()=="打开"){
-            input="";
-            JFileChooser jfc=new JFileChooser();
-            jfc.setFileSelectionMode(JFileChooser.OPEN_DIALOG );
+        if (actionEvent.getActionCommand() == "打开") {
+            input = "";
+            JFileChooser jfc = new JFileChooser();
+            jfc.setFileSelectionMode(JFileChooser.OPEN_DIALOG);
             jfc.showDialog(new JLabel(), "打开代码文件");
-            File file=jfc.getSelectedFile();
+            File file = jfc.getSelectedFile();
             try {
                 InputStreamReader read = new InputStreamReader(new FileInputStream(file));
                 BufferedReader bufferedReader = new BufferedReader(read);
                 String temp;
                 while ((temp = bufferedReader.readLine()) != null) {
-                    input=input+temp+'\n';
+                    input = input + temp + '\n';
                 }
                 read.close();
-            }catch (IOException e){
+            } catch (IOException e) {
                 e.printStackTrace();
             }
             textAreas[0].setText(input);
             textAreas[0].setCaretPosition(0);//光标置顶
         }
-        if(actionEvent.getActionCommand()=="保存"){
-            JFileChooser jfc=new JFileChooser();
+        if (actionEvent.getActionCommand() == "保存") {
+            JFileChooser jfc = new JFileChooser();
             jfc.setFileSelectionMode(JFileChooser.SAVE_DIALOG);
-            jfc.showDialog(new JLabel(),"保存");
-            File file=jfc.getSelectedFile();
+            jfc.showDialog(new JLabel(), "保存");
+            File file = jfc.getSelectedFile();
             try {
-                OutputStreamWriter write=new OutputStreamWriter(new FileOutputStream(file));
-                BufferedWriter bw=new BufferedWriter(write);
+                OutputStreamWriter write = new OutputStreamWriter(new FileOutputStream(file));
+                BufferedWriter bw = new BufferedWriter(write);
                 bw.write(output);
                 bw.flush();
                 write.close();
-            }catch (IOException e){
+            } catch (IOException e) {
                 e.printStackTrace();
             }
         }
-        if(actionEvent.getActionCommand()=="分析"){
+        if (actionEvent.getActionCommand() == "分析") {
             model.setRowCount(0);//清空表格
-            input=textAreas[0].getText();
+            input = textAreas[0].getText();
             Analysis.LexicalAnalysis(input);//分析字符串
-            ArrayList<String> values=Analysis.getValues();
-            ArrayList<String> types=Analysis.getTypes();
-            for(int i=0;i<values.size();i++){
-                model.addRow(new String[]{types.get(i),values.get(i)});//必须先添加一行才能赋值，当然也可以addRow一个向量
+            ArrayList<String> values = Analysis.getValues();
+            ArrayList<String> types = Analysis.getTypes();
+            for (int i = 0; i < values.size(); i++) {
+                model.addRow(new String[]{types.get(i), values.get(i)});//必须先添加一行才能赋值，当然也可以addRow一个向量
             }
-            ArrayList<String> errors=Analysis.getErrors();
-            ArrayList<String> errorvalues=Analysis.getErrorvalues();
-            ArrayList<Integer> errorsRows=Analysis.getErrorsRows();
-            if(errors.isEmpty()){
+            ArrayList<String> errors = Analysis.getErrors();
+            ArrayList<String> errorvalues = Analysis.getErrorvalues();
+            ArrayList<Integer> errorsRows = Analysis.getErrorsRows();
+            if (errors.isEmpty()) {
                 textAreas[1].setText("NO ERROR!!");
-            }else{
-                output="";
-                for(int i=0;i<errors.size();i++){
-                    output+=(errorsRows.get(i)+" 行："+errorvalues.get(i)+"  "+errors.get(i)+'\n');
+            } else {
+                output = "";
+                for (int i = 0; i < errors.size(); i++) {
+                    output += (errorsRows.get(i) + " 行：" + errorvalues.get(i) + "  " + errors.get(i) + '\n');
                 }
                 textAreas[1].setText(output);
-                output+="---------------------\n";
-                for(int i=0;i<values.size();i++){
-                    output+=("("+types.get(i)+","+values.get(i)+")"+'\n');
+                output += "---------------------\n";
+                for (int i = 0; i < values.size(); i++) {
+                    output += ("(" + types.get(i) + "," + values.get(i) + ")" + '\n');
                 }
             }
         }
-        if(actionEvent.getActionCommand()=="状态转换图"){
-            JFrame f=new JFrame("状态转换图");
+        if (actionEvent.getActionCommand() == "状态转换图") {
+            JFrame f = new JFrame("状态转换图");
             //f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-            f.setSize(800,800);
+            f.setSize(800, 800);
             f.setLocationRelativeTo(null);
-            DrawPanel dp=new DrawPanel();
-            dp.setPreferredSize(new Dimension(3000,3000));
-            JScrollPane jsp=new JScrollPane(dp);
-            jsp.setPreferredSize(new Dimension(1000,600));
+            DrawPanel dp = new DrawPanel();
+            dp.setPreferredSize(new Dimension(3000, 3000));
+            JScrollPane jsp = new JScrollPane(dp);
+            jsp.setPreferredSize(new Dimension(1000, 600));
             jsp.getVerticalScrollBar().setUnitIncrement(20);//设置滚动速度
             f.add(jsp);
             f.setExtendedState(JFrame.MAXIMIZED_BOTH);
@@ -155,62 +154,82 @@ class LexicalWindow extends ModWindow{
         }
     }
 
-    class DrawPanel extends JPanel{
+    class DrawPanel extends JPanel {
 
         private Graphics2D g2d;
-        private void drawStatus(int x, int y, int str){
-            g2d.setFont(new Font("XHei Apple",Font.PLAIN,25));
-            g2d.drawOval(x,y,50,50);
-            g2d.drawString(str+"",x+20,y+35);
+
+        private void drawStatus(int x, int y, int str) {
+            g2d.setFont(new Font("XHei Apple", Font.PLAIN, 25));
+            g2d.drawOval(x, y, 50, 50);
+            g2d.drawString(str + "", x + 20, y + 35);
         }
 
-        private void drawFinalStatus(int x, int y, int str){
-            g2d.drawOval(x+3,y+3,44,44);
-            drawStatus(x,y,str);
+        private void drawFinalStatus(int x, int y, int str) {
+            g2d.drawOval(x + 3, y + 3, 44, 44);
+            drawStatus(x, y, str);
         }
+
         //循环
-        private void drawCycle(int x, int y, String str){
-            g2d.setFont(new Font("XHei Apple",Font.PLAIN,20));
-            g2d.drawOval(x+7,y-35,35,35);
-            g2d.drawString(str,x,y-45);
-            g2d.drawPolyline(new int[]{x+30,x+25,x+30},new int[]{y-30,y-35,y-40},3);
+        private void drawCycle(int x, int y, String str) {
+            g2d.setFont(new Font("XHei Apple", Font.PLAIN, 20));
+            g2d.drawOval(x + 7, y - 35, 35, 35);
+            g2d.drawString(str, x, y - 45);
+            g2d.drawPolyline(new int[]{x + 30, x + 25, x + 30}, new int[]{y - 30, y - 35, y - 40}, 3);
         }
+
         //起点x,y 宽度固定200
-        private void drawX(int x, int y, String str){
-            g2d.setFont(new Font("XHei Apple",Font.PLAIN,20));
-            g2d.drawLine(x+50,y+25,x+200,y+25);
-            g2d.fillPolygon(new int[]{x+200,x+180,x+180},new int[]{y+25,y+30,y+20},3);
-            g2d.drawString(str+"",x+60,y+25);
+        private void drawX(int x, int y, String str) {
+            g2d.setFont(new Font("XHei Apple", Font.PLAIN, 20));
+            g2d.drawLine(x + 50, y + 25, x + 200, y + 25);
+            g2d.fillPolygon(new int[]{x + 200, x + 180, x + 180}, new int[]{y + 25, y + 30, y + 20}, 3);
+            g2d.drawString(str + "", x + 60, y + 25);
         }
 
 
-        String changeInput(int x){
-            switch (x){
-                case 0:return "空格&tab";
-                case 1:return "l";
-                case 2:return "d";
-                case 3:return "=";
-                case 4:return "双界符";
-                case 5:return "单界符";
-                case 6:return "+";
-                case 7:return "-";
-                case 8:return "*";
-                case 9:return "/";
-                case 10:return ":";
-                case 11:return "<";
-                case 12:return ">";
-                case 13:return "|";
-                case 14:return "&";
-                case 15:return "小数点";
-                case 16:return "\\n";
+        String changeInput(int x) {
+            switch (x) {
+                case 0:
+                    return "空格&tab";
+                case 1:
+                    return "l";
+                case 2:
+                    return "d";
+                case 3:
+                    return "=";
+                case 4:
+                    return "双界符";
+                case 5:
+                    return "单界符";
+                case 6:
+                    return "+";
+                case 7:
+                    return "-";
+                case 8:
+                    return "*";
+                case 9:
+                    return "/";
+                case 10:
+                    return ":";
+                case 11:
+                    return "<";
+                case 12:
+                    return ">";
+                case 13:
+                    return "|";
+                case 14:
+                    return "&";
+                case 15:
+                    return "小数点";
+                case 16:
+                    return "\\n";
             }
             return "其它";
         }
 
-        boolean isFinal(int x){
-            int a[]={2,4,7,8,9,10,11,12,13,14,15,17,20,22,23,24,25,26,27,28,29,30,31,32,33};
-            for (int i=0;i<a.length;i++){
-                if(x==a[i])
+        boolean isFinal(int x) {
+            int a[] = {2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33};
+            for (int i = 0; i < a.length; i++) {
+                if (x == a[i])
                     return true;
             }
             return false;
@@ -218,130 +237,130 @@ class LexicalWindow extends ModWindow{
 
         @Override
         protected void paintComponent(Graphics graphics) {
-            int [][]a;//存放状态转换矩阵
-            a=new int[][]{{0,1,3,9,10,11,12,13,14,15,21,24,27,29,31,-1,-1,33},
-                    {-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {4,-1,3,-1,4,4,-1,-1,-1,-1,-1,-1,-1,4,4,5,4,8},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8},
-                    {7,-1,6,-1,7,7,-1,-1,-1,-1,-1,-1,-1,7,7,-1,4,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,18,16,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,17,16},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1,-1,-1,-1,18},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,-1,-1,18},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,22},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,25,-1,-1,-1,-1,-1,-1,-1,-1,26,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,28,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,30,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,32,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
-                    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}
+            super.paintComponent(graphics);
+            g2d = (Graphics2D) graphics.create();
+
+            int[][] a;//存放状态转换矩阵
+            a = new int[][]{{0, 1, 3, 9, 10, 11, 12, 13, 14, 15, 21, 24, 27, 29, 31, -1, -1, 33},
+                    {-1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {4, -1, 3, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, 4, 5, 4, 8},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8},
+                    {7, -1, 6, -1, 7, 7, -1, -1, -1, -1, -1, -1, -1, 7, 7, -1, 4, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, 18, 16, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 16},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, 18},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, 18},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
+                    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
             };
 
-            super.paintComponent(graphics);
-            g2d=(Graphics2D)graphics.create();
 
             g2d.setColor(Color.BLACK);
             g2d.setStroke(new BasicStroke(2.0f));//设置线宽
-            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);//消除文字锯齿
+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);//消除文字锯齿
             g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);//消除画图锯齿
-            g2d.setFont(new Font("XHei Apple",Font.PLAIN,20));
+            g2d.setFont(new Font("XHei Apple", Font.PLAIN, 20));
 
-            int[] flag=new int[a.length];//是否已画出标记
-            int[] x=new int[a.length];//x坐标
-            int[] y=new int[a.length];//y坐标
-            flag[0]=1;
-            x[0]=150;
-            y[0]=95;
-            g2d.drawArc(x[0]-50,y[0]-75,100,100,-180,90);
-            g2d.drawPolyline(new int[]{x[0]-5,x[0],x[0]-5},new int[]{y[0]+20,y[0]+25,y[0]+30},3);
-            g2d.drawString("init",x[0]-25,y[0]);
-            drawStatus(x[0],y[0],0);
+            int[] flag = new int[a.length];//是否已画出标记
+            int[] x = new int[a.length];//x坐标
+            int[] y = new int[a.length];//y坐标
+            flag[0] = 1;
+            x[0] = 150;
+            y[0] = 95;
+            g2d.drawArc(x[0] - 50, y[0] - 75, 100, 100, -180, 90);
+            g2d.drawPolyline(new int[]{x[0] - 5, x[0], x[0] - 5}, new int[]{y[0] + 20, y[0] + 25, y[0] + 30}, 3);
+            g2d.drawString("init", x[0] - 25, y[0]);
+            drawStatus(x[0], y[0], 0);
 
-            int[] s=new int[100];//存放起始状态
-            int[] e=new int[100];//存放终止状态
-            int edgeNum=0;
+            int[] s = new int[100];//存放起始状态
+            int[] e = new int[100];//存放终止状态
+            int edgeNum = 0;
 
-            for(int i=0;i<a.length;i++){
-                int num=0;//记录此状态有几个下一个状态
-                for(int j=0;j<a[0].length;j++){
+            for (int i = 0; i < a.length; i++) {
+                int num = 0;//记录此状态有几个下一个状态
+                for (int j = 0; j < a[0].length; j++) {
                     //如果这两个边已经有边相连，则跳过这次循环
-                    int flag2=0;
-                    for(int w=0;w<edgeNum;w++){
-                        if(s[w]==i&&e[w]==a[i][j])
-                            flag2=1;
+                    int flag2 = 0;
+                    for (int w = 0; w < edgeNum; w++) {
+                        if (s[w] == i && e[w] == a[i][j])
+                            flag2 = 1;
                     }
-                    if(flag2==1)
+                    if (flag2 == 1)
                         continue;
                     //接下来的状况就是两个状态没有被边相连
                     //如果下一个状态存在
-                    if(a[i][j]>=0){
-                        String str=changeInput(j);
-                        for(int k=j+1;k<a[0].length;k++){
-                            if(a[i][k]==a[i][j])
-                                str=str+","+changeInput(k);
+                    if (a[i][j] >= 0) {
+                        String str = changeInput(j);
+                        for (int k = j + 1; k < a[0].length; k++) {
+                            if (a[i][k] == a[i][j])
+                                str = str + "," + changeInput(k);
                         }
                         //如果下一个状态未被画出
                         //画出下一个状态并设置其状态为已画出
                         //并记录下一个状态的x坐标和y坐标
                         //下一个状态的数量+1
-                        if(flag[a[i][j]]==0){
+                        if (flag[a[i][j]] == 0) {
                             //如果下一个状态有两个
-                            if(num==1){
-                                g2d.drawLine(x[i]+25,y[i]+100*num+45,x[i]+25,y[i]+100*num-50);
-                                g2d.drawLine(x[i]+50,y[i]+120*num+25,x[i]+25,y[i]+120*num+25);
+                            if (num == 1) {
+                                g2d.drawLine(x[i] + 25, y[i] + 100 * num + 45, x[i] + 25, y[i] + 100 * num - 50);
+                                g2d.drawLine(x[i] + 50, y[i] + 120 * num + 25, x[i] + 25, y[i] + 120 * num + 25);
                             }
                             //下一个状态有两个以上的时候，表示状态的圆球就不占据长度了，和有两个状态的时候不同
-                            if(num>1){
-                                g2d.drawLine(x[i]+25,y[i]+120*num+25,x[i]+25,y[i]+120*num-100);
-                                g2d.drawLine(x[i]+50,y[i]+120*num+25,x[i]+25,y[i]+120*num+25);
+                            if (num > 1) {
+                                g2d.drawLine(x[i] + 25, y[i] + 120 * num + 25, x[i] + 25, y[i] + 120 * num - 100);
+                                g2d.drawLine(x[i] + 50, y[i] + 120 * num + 25, x[i] + 25, y[i] + 120 * num + 25);
                             }
 
-                            drawX(x[i],y[i]+120*num,str);
+                            drawX(x[i], y[i] + 120 * num, str);
                             //判断是否为终态
-                            if(isFinal(a[i][j])){
+                            if (isFinal(a[i][j])) {
                                 drawFinalStatus(x[i] + 200, y[i] + 120 * num, a[i][j]);
-                            }else {
+                            } else {
                                 drawStatus(x[i] + 200, y[i] + 120 * num, a[i][j]);
                             }
-                            flag[a[i][j]]=1;
-                            x[a[i][j]]=x[i]+200;
-                            y[a[i][j]]=y[i]+120*num;
+                            flag[a[i][j]] = 1;
+                            x[a[i][j]] = x[i] + 200;
+                            y[a[i][j]] = y[i] + 120 * num;
                             num++;
                         }
                         //如果下一个状态已被画出
-                        else{
+                        else {
                             //如果下一个状态就是自身
-                            if(i==a[i][j]){
-                                drawCycle(x[i],y[i],str);
-                            }
-                            else{
+                            if (i == a[i][j]) {
+                                drawCycle(x[i], y[i], str);
+                            } else {
                                 //计算x和y的距离
-                                g2d.drawLine(x[i]+50,y[i]+25,x[a[i][j]]+25,y[a[i][j]]+50);
-                                g2d.fillRect(x[a[i][j]]+25,y[a[i][j]]+50,8,8);
-                                g2d.drawString(str,(x[a[i][j]]+x[i]+75)/2,(y[a[i][j]]+y[i]+75)/2);
+                                g2d.drawLine(x[i] + 50, y[i] + 25, x[a[i][j]] + 25, y[a[i][j]] + 50);
+                                g2d.fillRect(x[a[i][j]] + 25, y[a[i][j]] + 50, 8, 8);
+                                g2d.drawString(str, (x[a[i][j]] + x[i] + 75) / 2, (y[a[i][j]] + y[i] + 75) / 2);
 
                             }
                         }
-                        s[edgeNum]=i;
-                        e[edgeNum]=a[i][j];
+                        s[edgeNum] = i;
+                        e[edgeNum] = a[i][j];
                         edgeNum++;
                     }
                 }
diff --git a/Compiles/ParseWindow.java b/Compiles/ParseWindow.java
index e0d77f7..213884a 100644
--- a/Compiles/ParseWindow.java
+++ b/Compiles/ParseWindow.java
@@ -26,7 +26,7 @@ class ParseWindow extends ModWindow implements ItemListener {
     JLabel label=new JLabel("语法分析方法：");
     JButton b=new JButton("分析");
     ButtonGroup bg=new ButtonGroup();
-    String[] radioButtonText={"算符优先","LR(0)"};
+    String[] radioButtonText={"算符优先","SLR(1)"};
     JRadioButton[] radioButton=new JRadioButton[2];
 
 
@@ -102,7 +102,7 @@ class ParseWindow extends ModWindow implements ItemListener {
                         {"i", ">", ">", ">", ">",    "", "", ">", ">"},
                         {"(", "<", "<", "<", "<",    "<", "<", "=", ""},
                         {")", ">", ">", ">", ">",    "", "", ">", ">"},
-                        {"#", "<", "<", "<", "<",    "<", "<", "", ""},
+                        {"#", "<", "<", "<", "<",    "<", "<", "", "="},
                 };
                 model2.setColumnIdentifiers(new String[]{"","+","-","*","/","i","(",")","#"});
                 model2.setRowCount(0);//清空表格
@@ -114,19 +114,24 @@ class ParseWindow extends ModWindow implements ItemListener {
             if (btn.isSelected() && btn.getText() == radioButtonText[1]) {
                 isSuanfu=false;
                 String[][] sheet = new String[][]{
-                        {"0", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"1", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"2", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"3", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"4", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"5", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"6", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"7", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"8", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"9", "", "", "", "", "", "", "", "", "", "", ""},
-                        {"10", "", "", "", "", "", "", "", "", "", "", ""},
+                        {"0","S4","","","","","","S5","","1","2","3"},
+                        {"1","","","S6","S7","","","","Acc","","",""},
+                        {"2","","R3","R3","R3","S8","S9","","R3","","",""},
+                        {"3","","R6","R6","R6","R6","R6","","R6","","",""},
+                        {"4","S4","","","","","","S5","","10","2","3"},
+                        {"5","","R8","R8","R8","R8","R8","","R8","","",""},
+                        {"6","S4","","","","","","S5","","","11","3"},
+                        {"7","S4","","","","","","S5","","","12","3"},
+                        {"8","S4","","","","","","S5","","","","13"},
+                        {"9","S4","","","","","","S5","","","","14"},
+                        {"10","","S15","S6","S7","","","","","","",""},
+                        {"11","","R1","R1","R1","S8","S9","","R1","","",""},
+                        {"12","","R2","R2","R2","S8","S9","","R2","","",""},
+                        {"13","","R4","R4","R4","R4","R4","","R4","","",""},
+                        {"14","","R5","R5","R5","R5","R5","","R5","","",""},
+                        {"15","","R7","R7","R7","R7","R7","","R7","","",""}
                 };
-                model2.setColumnIdentifiers(new String[]{"","E","T","F","+","-","*","/","i","(",")","#"});
+                model2.setColumnIdentifiers(new String[]{"","(",")","+","-","*","/","i","#","E","T","F"});
                 model2.setRowCount(0);//清空表格
                 for (int i = 0; i < sheet.length; i++) {
                     model2.addRow(sheet[i]);
@@ -143,17 +148,21 @@ class ParseWindow extends ModWindow implements ItemListener {
 
     @Override
     public void actionPerformed(ActionEvent actionEvent) {
-        class MyThread extends Thread{
-            @Override
-            public void run() {
-                Analysis.ParseAnalysis(model,model2,t2);
-            }
-        }
         if(isSuanfu){
-            new MyThread().start();
+            new Thread(){
+                @Override
+                public void run() {
+                    Analysis.ParseAnalysis(model,model2);
+                }
+            }.start();
         }
         if(!isSuanfu){
-            System.out.println("不是算符");
+            new Thread(){
+                @Override
+                public void run() {
+                    Analysis.ParseAnalysis_SLR(model,model2);
+                }
+            }.start();
         }
     }
 }
\ No newline at end of file
-- 
2.21.0.windows.1

